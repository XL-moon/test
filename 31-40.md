## 31-40题
### 三十一、连续子数组的最大和
#### 题目及思路
```java<br>
题目：
求连续子数组（包含负数）的最大和
思路：
若和小于0，则将最大和置为当前值，否则计算最大和。
```
#### 代码
```java<br>
代码实现：

    public int FindGreatestSumOfSubArray(int[] array) {
        if (array == null || array.length == 0)
            return 0;
        int cur = array[0];
        int greast = array[0];

        for (int i = 1; i < array.length; i++) {
            if (cur < 0) {
                cur = array[i];
            }else {
                cur += array[i];
            }

            if (cur > greast) {
                greast = cur;
            }
        }
        return greast;
    }
```

### 三十二、从1到整数n中1出现的次数
#### 题目及思路
```java<br>
题目：
从1到非负整数n中1出现的次数
思路：
若百位上数字为0，百位上可能出现1的次数由更高位决定；若百位上数字为1，百位上可能出现1的次数不仅受更高位影响还受低位影响；
若百位上数字大于1，则百位上出现1的情况仅由更高位决定
```
#### 解法1
```java<br>
代码实现：

    public long CountOne2(long n) {
        long count = 0; // 1的个数
        long i = 1;  // 当前位
        long current = 0,after = 0,before = 0;

        while((n / i) != 0) {
            before = n / (i * 10); // 高位
            current = (n / i) % 10; // 当前位
            after = n - (n / i) * i;  // 低位

            if (current == 0)
                //如果为0,出现1的次数由高位决定,等于高位数字 * 当前位数
                count = count + before * i;
            else if(current == 1)
                //如果为1,出现1的次数由高位和低位决定,高位*当前位+低位+1
                count = count + before * i + after + 1;
            else if (current > 1)
                // 如果大于1,出现1的次数由高位决定,（高位数字+1）* 当前位数
                count = count + (before + 1) * i;
            //前移一位
            i = i * 10;
        }
        return count;
    }
```
#### 解法2
```java<br>
解法二：公式法

    public int NumberOf1Between1AndN_Solution(int n){
        int count=0;

        for(int i = 1; i <= n; i *= 10){
            int a = n / i; // 高位
            int b = n % i; // 低位
            count += (a+8) / 10 * i;
            if(a % 10 == 1){
                count += b + 1;
            }
        }
        return count;
    }
```

### 三十三、把数组中的数排成一个最小的数
#### 题目及思路
```java<br>
题目：
输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个
思路：
先将整型数组转换成String数组，然后将String数组排序，最后将排好序的字符串数组拼接出来。
关键就是制定排序规则。或使用比较和快排的思想，将前面的数和最后的数比较，若小则放到最前面，最后再递归调用。
```
#### 代码
```java<br>
代码实现：

    public String PrintMinNumber(int [] numbers) {
        if(numbers == null || numbers.length == 0)
            return "";
        int len = numbers.length;
        String[] str = new String[len];
        StringBuilder sb = new StringBuilder();
        for(int i = 0; i < len; i++){
            str[i] = String.valueOf(numbers[i]);
        }
        Arrays.sort(str,new Comparator<String>(){
            @Override
            public int compare(String s1, String s2) {
                String c1 = s1 + s2;
                String c2 = s2 + s1;
                return c1.compareTo(c2);
            }
        });

        for(int i = 0; i < len; i++){
            sb.append(str[i]);
        }
        return sb.toString();
    }
```
